<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="描述根据名字就知道这是一个缓存类，具体点是一个键值对存储的缓存类，至于weak的含义是因为这里的键与值都是弱引用，除此之外，这里所说的缓存是一个二级缓存。第一层是弱引用，第二层是强引用。 实现二级缓存12private final ConcurrentMap&amp;lt;Object, ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt;&amp;gt; map = ne">
<meta name="keywords" content="java,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Java源码阅读------WeakCache">
<meta property="og:url" content="http://yoursite.com/2019/02/14/Java源码阅读WeakCache/index.html">
<meta property="og:site_name" content="yanzs_博客">
<meta property="og:description" content="描述根据名字就知道这是一个缓存类，具体点是一个键值对存储的缓存类，至于weak的含义是因为这里的键与值都是弱引用，除此之外，这里所说的缓存是一个二级缓存。第一层是弱引用，第二层是强引用。 实现二级缓存12private final ConcurrentMap&amp;lt;Object, ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt;&amp;gt; map = ne">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-04T09:55:00.841Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java源码阅读------WeakCache">
<meta name="twitter:description" content="描述根据名字就知道这是一个缓存类，具体点是一个键值对存储的缓存类，至于weak的含义是因为这里的键与值都是弱引用，除此之外，这里所说的缓存是一个二级缓存。第一层是弱引用，第二层是强引用。 实现二级缓存12private final ConcurrentMap&amp;lt;Object, ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt;&amp;gt; map = ne">






  <link rel="canonical" href="http://yoursite.com/2019/02/14/Java源码阅读WeakCache/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java源码阅读------WeakCache | yanzs_博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yanzs_博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/Java源码阅读WeakCache/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yanzs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yanzs_博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java源码阅读------WeakCache

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-14 19:39:50" itemprop="dateCreated datePublished" datetime="2019-02-14T19:39:50+08:00">2019-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-04 17:55:00" itemprop="dateModified" datetime="2019-03-04T17:55:00+08:00">2019-03-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>根据名字就知道这是一个缓存类，具体点是一个键值对存储的缓存类，至于weak的含义是因为这里的键与值都是弱引用，除此之外，这里所说的缓存是一个二级缓存。第一层是弱引用，第二层是强引用。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这里的map就是一个二级缓存的实现机制，Object（最左边的）就是key（键），第二个Object为subKey（子键），最后的Supplier&lt; V &gt;接口为值，实际是一个包裹最终是由其中的get方法来获取值。这种设计保证了key为null时也可用。reverseMap用于标注每个Supplier&lt; V &gt;的可用情况，用于缓存的过期处理。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>这里的K，P，V分别是键、参数、值，传入的参数是两个BiFunction接口，主要使用的是其中的apply方法，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>通过传入的两个参数来获取值，使用这一接口实现了两个简单的工厂，subKeyFactory，valueFactory，这两个工厂分别实现了通过K与P来获取subKey（子键）和通过K，P来获取value值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakCache</span><span class="params">(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">	<span class="keyword">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以通过subKeyFactory ，valueFactory 获取对应的子键与值。</p>
<h3 id="CacheValue"><a href="#CacheValue" class="headerlink" title="CacheValue"></a>CacheValue</h3><p>静态内部类，实际上就是用于存储一个值的对象。<br>先看看WeakCache中的Value接口继承自Supplier接口，实际上是为了实现get方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Value</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">CacheValue(V value) &#123;</span><br><span class="line">	<span class="keyword">super</span>(value);</span><br><span class="line">    <span class="keyword">this</span>.hash = System.identityHashCode(value); <span class="comment">// compare by identity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了传入的Value的实例保存，同时通过System.identityHashCode(value);函数获取了该Value的HashCode。</p>
<h4 id="hashCode与identityHashCode"><a href="#hashCode与identityHashCode" class="headerlink" title="hashCode与identityHashCode"></a>hashCode与identityHashCode</h4><p>在Object类中的hashCode可以获取相应对象的hashCode，而这个identityHashCode也是可以获取对象的hashCode，那么两这有什么不同吗？从源码看两者都是本地方法（native），实际上获取时的结果是与hashCode无异的，但是这里的hashCode指的是原有的Object中的hashCode的方法，如果进行了重写就可能会有不同了，所以为了得到原有的Object中的hashCode的值，identityHashCode会比较方便。</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p>重写的hashCode方法，直接返回hash值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>重写的equals方法，用于判别传入的obj与弱引用中的value是否相同，这里的get()方法就是返回之前传入的弱引用的value。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	V value;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">this</span> || obj <span class="keyword">instanceof</span> Value &amp;&amp;</span><br><span class="line">            (value = get()) != <span class="keyword">null</span> &amp;&amp;  value == ((Value&lt;?&gt;) obj).get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LookupValue"><a href="#LookupValue" class="headerlink" title="LookupValue"></a>LookupValue</h3><p>静态内部类，为了便于对CacheValue中的值进行判断，建立了LookupValue，也实现了Value接口，是CacheValue运算时的替代，实现方式也很相似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> V value;<span class="comment">//存储实际的值</span></span><br><span class="line"></span><br><span class="line">      LookupValue(V value) &#123;<span class="comment">//构造方法</span></span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="comment">//Value接口中的get方法，返回value的值</span></span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> System.identityHashCode(value); <span class="comment">//一样的hashCode计算</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> obj == <span class="keyword">this</span> ||</span><br><span class="line">                 obj <span class="keyword">instanceof</span> Value &amp;&amp;</span><br><span class="line">                 <span class="keyword">this</span>.value == ((Value&lt;?&gt;) obj).get();  <span class="comment">// 类似的equals重写</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h3><p>静态内部类，CacheKey直接继承了使用引用队列的弱引用，来存储键值。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p>实现的过程与CacheValue中的类似，只不过这里使用引用队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CacheKey</span><span class="params">(K key, ReferenceQueue&lt;K&gt; refQueue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(key, refQueue);</span><br><span class="line">    <span class="keyword">this</span>.hash = System.identityHashCode(key); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这里有一点注意，这里的构造方法是private的也就是说无法从外界直接调用，那么是如何构建出实例对象的呢？</p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p>这是一个静态方法，传入的是要保存的key与对应的请求队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K&gt; <span class="function">Object <span class="title">valueOf</span><span class="params">(K key, ReferenceQueue&lt;K&gt; refQueue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> key == <span class="keyword">null</span> ? NULL_KEY : <span class="keyword">new</span> CacheKey&lt;&gt;(key, refQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的NULL_KEY是一个标识用于标注key为空的情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<h4 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h4><p>这里重写了hashCode与equals方法，基本的实现与CacheValue相同，不再赘述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	K key;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">this</span> || obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           obj.getClass() == <span class="keyword">this</span>.getClass() &amp;&amp; (key = <span class="keyword">this</span>.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           key == ((CacheKey&lt;K&gt;) obj).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的get方法是引用Reference中定义的与之后描述的get方法不同。</p>
<h4 id="expungeFrom"><a href="#expungeFrom" class="headerlink" title="expungeFrom"></a>expungeFrom</h4><p>通过这个方法可以将含有这个键值的相关缓存清除。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expungeFrom</span><span class="params">(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map, ConcurrentMap&lt;?, Boolean&gt; reverseMap)</span> </span>&#123;</span><br><span class="line">	ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(<span class="keyword">this</span>);<span class="comment">//直接从二级缓存中清除，并获取第二级的缓存map</span></span><br><span class="line">    <span class="keyword">if</span> (valuesMap != <span class="keyword">null</span>) &#123;<span class="comment">//遍历第二级缓存并在reverseMap中清除</span></span><br><span class="line">    	<span class="keyword">for</span> (Object cacheValue : valuesMap.values()) &#123;</span><br><span class="line">        	reverseMap.remove(cacheValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><p>二级缓存的构建过程是通过这个静态内部类实现的，实现了Supplier<v>接口。</v></p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> P parameter;<span class="comment">//参数</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Object subKey;<span class="comment">//子键</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;<span class="comment">//二级缓存</span></span><br><span class="line"></span><br><span class="line">      Factory(K key, P parameter, Object subKey, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">          <span class="keyword">this</span>.key = key;</span><br><span class="line">          <span class="keyword">this</span>.parameter = parameter;</span><br><span class="line">          <span class="keyword">this</span>.subKey = subKey;</span><br><span class="line">          <span class="keyword">this</span>.valuesMap = valuesMap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>简单的数据准备工作。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>这就是构建的具体过程了，实现了Supplier<v>中的get方法,通过同步synchronized来保持线程安全<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">          <span class="comment">// 这里有一个检查，为啥检查先买个关子，到之后WeakCatch的get方法再做细究</span></span><br><span class="line">          Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">          <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          V value = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">              <span class="comment">//通过key与parameter处理出value</span></span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 失败的处理</span></span><br><span class="line">                  valuesMap.remove(subKey, <span class="keyword">this</span>);<span class="comment">//移除相应的subKey对应的缓存</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 检查value是否完成建立</span></span><br><span class="line">          <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 包裹一下value建立一个cacheValue</span></span><br><span class="line">          CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line">          <span class="comment">// 将subKey中的二级缓存中原本的Factory换成包装过的cacheValue，至于为啥一开始二级缓存中会将Factory放进去我们也将其放到WeakCatch的get方法中解释</span></span><br><span class="line">          <span class="keyword">if</span> (valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">              <span class="comment">// 加入reverseMap中标记Value可用</span></span><br><span class="line">              reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//出错时的异常处理</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//处理成功后将value返回</span></span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></v></p>
<h3 id="expungeStaleEntries"><a href="#expungeStaleEntries" class="headerlink" title="expungeStaleEntries"></a>expungeStaleEntries</h3><p>由于二级缓存中的Key使用了弱引用，所以在实际使用时gc的不定期处理会导致部分的缓存失效，通过这个函数就可以实现对失效缓存的清除。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;K&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       CacheKey&lt;K&gt; cacheKey;</span><br><span class="line">       <span class="keyword">while</span> ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           cacheKey.expungeFrom(map, reverseMap);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>refQueue是弱引用中的引用队列，在创建CacheKey时传入。（建议了解弱引用后继续）。<br>当gc处理了部分CacheKey时，refQueue中会有CacheKey的引用，取出来后在调用expungeFrom方法来清除过期的缓存。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>同样的在获取可用的缓存数量时也使用了expungeStaleEntries来先清除过期的缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       expungeStaleEntries();</span><br><span class="line">       <span class="keyword">return</span> reverseMap.size();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h3><p>判断缓存中是否包含对应的value。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(value);<span class="comment">//对值进行判空</span></span><br><span class="line">       expungeStaleEntries();<span class="comment">//清除过期缓存</span></span><br><span class="line">       <span class="keyword">return</span> reverseMap.containsKey(<span class="keyword">new</span> LookupValue&lt;&gt;(value));<span class="comment">//使用LookupValue代替CacheValue使用，简化操作。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>压轴的高潮来了，这是整个类的灵魂所在，缓存中Value的值是由这个函数来获取的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//参数判空</span></span><br><span class="line">       Objects.requireNonNull(parameter);</span><br><span class="line">	<span class="comment">//清除过期缓存</span></span><br><span class="line">       expungeStaleEntries();</span><br><span class="line">	<span class="comment">//根据key生成相应的cacheKey </span></span><br><span class="line">       Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取二级缓存</span></span><br><span class="line">       ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">       <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有对应的二级缓存</span></span><br><span class="line">           ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());<span class="comment">//这里的putIfAbsent与put不同，put会直接替代，putIfAbsent是先判断是否含有值，如果有就返回对应值，如果没有就放入新值并返回null</span></span><br><span class="line">           <span class="comment">//如果之前含有值就使用之前的。</span></span><br><span class="line">           <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               valuesMap = oldValuesMap;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 通过subKeyFactory的apply方法创建subKey</span></span><br><span class="line">       Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">       <span class="comment">// 通过subKey获取相应的值</span></span><br><span class="line">       Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">       Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">       	<span class="comment">//缓存中有值且不为null就用get方法取出判空返回</span></span><br><span class="line">           <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 根据之前的Factory中的操作，我们知道这里的supplier可能是Factory或CacheValue&lt;V&gt;类型</span></span><br><span class="line">               V value = supplier.get();</span><br><span class="line">               <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> value;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//缓存没有成功取到或是没有缓存时，使用Factory进行加载。</span></span><br><span class="line">           <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           	<span class="comment">//创建factory</span></span><br><span class="line">               factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//不含缓存或取值为空的处理</span></span><br><span class="line">           <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">               supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">               <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//缓存加入成功，将最终的返回值设为factory在下一次循环时返回</span></span><br><span class="line">                   supplier = factory;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//之前含有缓存</span></span><br><span class="line">               <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;<span class="comment">//用新的factory进行替换</span></span><br><span class="line">                   <span class="comment">//成功替换后就将返回值设为factory在下一次循环时返回</span></span><br><span class="line">                   supplier = factory;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//替换失败则将其原来的值取出</span></span><br><span class="line">                   supplier = valuesMap.get(subKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>说到这里还有一个问题没有解决就是循环轮询的目的是啥，由于在实际使用时可能有多个线程对缓存中的值进行操作，所以使用轮询来不断的进行判断以获取最新的值，这里的get方法可以与factory中的get方法比较来看，就很好理解为啥在factory的get方法中要对取到的supplier进行判断了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>WeakCache是实现Proxy类的关键一环，其中二级缓存的设计思想很有研究的价值，特别是一些内部类的设计与使用，都可以给我们之后的编码带来启发。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/14/Java源码阅读Reference/" rel="next" title="Java源码阅读------Reference">
                <i class="fa fa-chevron-left"></i> Java源码阅读------Reference
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/14/Java技巧Reference引用/" rel="prev" title="Java技巧------Reference引用">
                Java技巧------Reference引用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yanzs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#描述"><span class="nav-number">1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二级缓存"><span class="nav-number">2.1.</span> <span class="nav-text">二级缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">2.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CacheValue"><span class="nav-number">2.3.</span> <span class="nav-text">CacheValue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode与identityHashCode"><span class="nav-number">2.3.2.</span> <span class="nav-text">hashCode与identityHashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode"><span class="nav-number">2.3.3.</span> <span class="nav-text">hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">2.3.4.</span> <span class="nav-text">equals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LookupValue"><span class="nav-number">2.4.</span> <span class="nav-text">LookupValue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CacheKey"><span class="nav-number">2.5.</span> <span class="nav-text">CacheKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-2"><span class="nav-number">2.5.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#valueOf-NaN"><span class="nav-number">2.5.2.</span> <span class="nav-text">valueOf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode与equals"><span class="nav-number">2.5.3.</span> <span class="nav-text">hashCode与equals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#expungeFrom"><span class="nav-number">2.5.4.</span> <span class="nav-text">expungeFrom</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Factory"><span class="nav-number">2.6.</span> <span class="nav-text">Factory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-3"><span class="nav-number">2.6.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">2.6.2.</span> <span class="nav-text">get</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expungeStaleEntries"><span class="nav-number">2.7.</span> <span class="nav-text">expungeStaleEntries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#size"><span class="nav-number">2.8.</span> <span class="nav-text">size</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#containsValue"><span class="nav-number">2.9.</span> <span class="nav-text">containsValue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-1"><span class="nav-number">2.10.</span> <span class="nav-text">get</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanzs</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.7.0</div>


<!-- 
  <div class="footer-custom">true</div>
 -->




  <div class="footer-custom">  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
 </div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  


  


  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
